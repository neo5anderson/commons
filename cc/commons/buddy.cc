// Generated by Neo

#include <commons/buddy.h>

#ifdef _POSIX_
#include <pthread.h>
#else
#warning without macro `_POSIX_`, thread non-safe!
#endif

#include <assert.h>
#include <stdio.h>
#include <string.h>

#include <commons/commons.h>

namespace commons {
const int8_t kNodeUnused = 0;
const int8_t kNodeUsed = 1;
const int8_t kNodeSplit = 2;
const int8_t kNodeFull = 3;

static inline size_t _level_size(uint8_t level) { return (1 << level) * 2 - 1; }

static inline int _parent(int index) { return (index + 1) / 2 - 1; }
static inline int _buddy(int index) { return index - 1 + (index & 1) * 2; }
static inline int _leaf_left(int index) { return index * 2 + 1; }
static inline int _leaf_right(int index) { return index * 2 + 2; }

static inline int _index_offset(int index, uint8_t level, uint8_t max_level) {
    return ((index + 1) - (1 << level)) << (max_level - level);
}

static inline void _lock(void* mutex) {
#ifdef _POSIX_
    if (nullptr != mutex) {
        pthread_mutex_lock(reinterpret_cast<pthread_mutex_t*>(mutex));
    }
#endif
}
static inline void _unlock(void* mutex) {
#ifdef _POSIX_
    if (nullptr != mutex) {
        pthread_mutex_unlock(reinterpret_cast<pthread_mutex_t*>(mutex));
    }
#endif
}

Buddy::Buddy(uint8_t level, buddy_clean_cb cb, void* user) {
    assert(0 < level && 31 > level);
    // tree size
    size_ = static_cast<int>(_level_size(level));

    level_ = level;
    tree_ = new uint8_t[size_];
    memset(tree_, kNodeUnused, size_);

    cb_ = cb;
    user_ = user;

    // max alloc size
    size_ = 1 << level;
    left_ = size_;

#ifdef _POSIX_
    mutex_ = new pthread_mutex_t;
    pthread_mutex_init(reinterpret_cast<pthread_mutex_t*>(mutex_), nullptr);
#else
    mutex_ = nullptr;
#endif
}
Buddy::~Buddy() {
    _lock(mutex_);
    clean(0, 0);
    _unlock(mutex_);

#ifdef _POSIX_
    if (nullptr != mutex_) {
        pthread_mutex_t* mutex = reinterpret_cast<pthread_mutex_t*>(mutex_);
        pthread_mutex_destroy(mutex);
        delete mutex;
    }
#endif

    cb_ = nullptr;
    user_ = nullptr;
    delete[] tree_;
}

void Buddy::mark(int index) {
    while (true) {
        int buddy = _buddy(index);

        if (buddy > 0 &&
            (kNodeUsed == tree_[buddy] || kNodeFull == tree_[buddy])) {
            index = _parent(index);
            tree_[index] = kNodeFull;
        } else {
            break;
        }
    }
}
int Buddy::alloc_with_mark(int s) {
    assert(0 <= s && size_ >= s);

    const int size =
        (0 == s) ? 1 : static_cast<int>(next_pow_of_2(static_cast<size_t>(s)));

    int index = 0;
    int level = 0;
    int length = 1 << level_;

    while (index >= 0) {
        if (size < length) {
            switch (tree_[index]) {
                case kNodeUsed:
                case kNodeFull:
                    // jump
                    break;

                case kNodeUnused:
                    // frist split
                    tree_[index] = kNodeSplit;
                    tree_[_leaf_left(index)] = kNodeUnused;
                    tree_[_leaf_right(index)] = kNodeUnused;
                default:
                    // parent -> leaf.left
                    index = _leaf_left(index);
                    ++level;
                    length >>= 1;
                    continue;
            }
        } else {
            // bingo
            if (kNodeUnused == tree_[index]) {
                tree_[index] = kNodeUsed;
                mark(index);
                left_ -= length;
                return _index_offset(index, level, level_);
            }
        }

        if (1 & index) {
            // left -> right
            ++index;
            continue;
        }

        while (true) {
            // leaf -> parent
            index = _parent(index);
            --level;
            length <<= 1;

            if (index < 0) {
                return kBuddyAllocFailed;
            }

            if (1 & index) {
                // left -> right
                ++index;
                break;
            }
        }
    }

    return kBuddyAllocFailed;
}
int Buddy::alloc(int size) {
    int locate = kBuddyAllocFailed;

    _lock(mutex_);
    locate = alloc_with_mark(size);
    _unlock(mutex_);

    return locate;
}

void Buddy::combine(int index) {
    while (true) {
        int buddy = _buddy(index);

        if (buddy < 0 || kNodeUnused != tree_[buddy]) {
            tree_[index] = kNodeUnused;
            // update parent
            while (((index = _parent(index)) >= 0) &&
                   kNodeFull == tree_[index]) {
                tree_[index] = kNodeSplit;
            }
            break;
        }

        index = _parent(index);
    }
}
void Buddy::free_with_combine(int offset) {
    assert((1 << level_) > offset);

    int left = 0;
    int index = 0;
    int length = 1 << level_;

    while (true) {
        switch (tree_[index]) {
            case kNodeUsed:
                // bingo
                assert(left == offset);
                combine(index);
                left_ += length;
                return;

            case kNodeUnused:
                assert(false);
                return;

            default:
                length >>= 1;
                // left or right
                if (left + length > offset) {
                    index = _leaf_left(index);
                } else {
                    left += length;
                    index = _leaf_right(index);
                }
                break;
        }
    }
}
void Buddy::free(int offset) {
    _lock(mutex_);
    free_with_combine(offset);
    _unlock(mutex_);
}

int Buddy::size_of_offset(int offset) {
    assert((1 << level_) > offset);

    if (offset < 0) {
        _lock(mutex_);
        int size = size_ - left_;
        _unlock(mutex_);
        return size;
    }

    int left = 0;
    int index = 0;
    int length = 1 << level_;

    while (true) {
        switch (tree_[index]) {
            case kNodeUsed:
                debug();
                return (left == offset) ? length : kBuddySizeBadOffset;

            case kNodeUnused:
                debug();
                return kBuddySizeUnallocated;

            default:
                length >>= 1;
                if (left + length > offset) {
                    index = _leaf_left(index);
                } else {
                    left += length;
                    index = _leaf_right(index);
                }
                break;
        }
    }
}
int Buddy::size(int offset) {
    int size = 0;

    _lock(mutex_);
    size = size_of_offset(offset);
    _unlock(mutex_);

    return size;
}

void Buddy::clean(int index, uint8_t level) {
    switch (tree_[index]) {
        case kNodeUsed: {
            int offset = _index_offset(index, level, level_);

            if (nullptr != cb_) {
                cb_(user_, offset);
            }

            free_with_combine(offset);
        } break;

        case kNodeSplit:
        case kNodeFull:
            // recursive
            clean(_leaf_left(index), level + 1);
            clean(_leaf_right(index), level + 1);
            break;

        default:
            break;
    }
}
void Buddy::clean() {
    _lock(mutex_);
    clean(0, 0);
    _unlock(mutex_);
}

void Buddy::dump(char* info, int index, uint8_t level) {
    switch (tree_[index]) {
        case kNodeUnused: {
            int count = 1 << (level_ - level);
            int offset = _index_offset(index, level, level_);

            for (int i = 0; i < count; ++i) {
                info[offset + i] = '-';
            }
        } break;

        case kNodeUsed: {
            int count = 1 << (level_ - level);
            int offset = _index_offset(index, level, level_);

            for (int i = 0; i < count; ++i) {
                info[offset + i] = '+';
            }
        } break;

        default:
            dump(info, _leaf_left(index), level + 1);
            dump(info, _leaf_right(index), level + 1);
            break;
    }
}
void Buddy::debug() {
#ifdef _DEBUG_
    char* info = new char[size_ + 1];

    _lock(mutex_);
    dump(info, 0, 0);
    _unlock(mutex_);

    info[size_] = '\0';
    LOGD("[%p] %s\n", this, info);

    delete[] info;
#endif
}
} /* namespace: commons */
