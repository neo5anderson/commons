// Generated by Neo

#include "handler_body.h"

#include <stdlib.h>

#include <commons/buddy.h>
#include <commons/handler.h>
#include <commons/message.h>
#include <commons/blocked_queue.h>

namespace commons {
const int buddy_level = 5;

void clean_msg_buddy(int offset, void* user) {}

void* handleLoop(void* handle) {
    HandlerBody* body = reinterpret_cast<HandlerBody*>(handle);
    body->queue_ = new BlockedQueue<Message>(do_nothing);
    body->is_working_ = true;

    if (nullptr == body || nullptr == body->parent_) {
        return nullptr;
    }

    while (body->is_working_) {
        Message* msg = body->queue_->poll();
        if (nullptr == msg) {
            break;
        }

        body->buddy_->free(msg->offset());
        body->parent_->handle(msg->what(), msg->arg1(), msg->arg2(),
                              msg->obj());
        // no need to delete
        msg->~Message();
    }

    body->pid_ = 0L;
    body->is_working_ = false;

    return body;
}

HandlerBody::HandlerBody(Handler* parent) {
    parent_ = parent;

    buddy_ = new Buddy(buddy_level);
    msg_pool_ =
        reinterpret_cast<Message*>(calloc(1 << buddy_level, sizeof(Message)));

    queue_ = nullptr;
    is_working_ = false;

    pid_ = 0L;
    pthread_create(&pid_, nullptr, handleLoop, this);
}
HandlerBody::~HandlerBody() {
    is_working_ = false;

    queue_->fin();

    if (0L != pid_) {
        pthread_join(pid_, nullptr);
    }

    delete queue_;

    delete buddy_;
    free(msg_pool_);
}

bool HandlerBody::send(int what, int arg1, int arg2, void* obj) const {
    bool result = false;

    int offset = buddy_->alloc(1);
    if (is_working_ && nullptr != queue_ && offset >= 0) {
        queue_->offer(new (msg_pool_ + offset)
                          Message(what, arg1, arg2, obj, offset));
        result = true;
    }

    return result;
}
} /* namespace: commons */
