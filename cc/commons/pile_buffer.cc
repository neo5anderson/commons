// Generated by Neo

#include <commons/pile_buffer.h>

#include <string.h>

#include <commons/commons.h>

namespace commons {
PileBuffer::PileBuffer(size_t capacity, pile_buffer_cb cb, void* user,
                       void* next_pile_ptr) {
    capacity_ = capacity;
    cb_ = cb;
    user_ = user;

    index_ = 0;
    left_ = capacity_;

    is_buffer_from_outer = (nullptr != next_pile_ptr);
    buffer_ = is_buffer_from_outer ? reinterpret_cast<uint8_t*>(next_pile_ptr)
                                   : new uint8_t[capacity_];

    mutex_ = new pthread_mutex_t;
    pthread_mutex_init(mutex_, nullptr);
}
PileBuffer::~PileBuffer() {
    pthread_mutex_lock(mutex_);
    cb_ = nullptr;
    pthread_mutex_unlock(mutex_);

    pthread_mutex_destroy(mutex_);
    delete mutex_;

    if (false == is_buffer_from_outer) {
        delete buffer_;
    }
}

bool PileBuffer::append(const void* data, size_t size, const void* additional) {
    bool result = false;

    if (nullptr != cb_ && nullptr != data && size > 0) {
        size_t offset = 0;
        uint8_t* next = nullptr;

        const uint8_t* pdata = reinterpret_cast<const uint8_t*>(data);

        pthread_mutex_lock(mutex_);
        while (left_ <= size) {
            memcpy(buffer_ + index_, pdata + offset, left_);
            offset += left_;
            size -= left_;

            if (nullptr != cb_) {
                next = reinterpret_cast<uint8_t*>(
                    cb_(user_, buffer_, capacity_, additional));

                if (nullptr != next) {
                    if (false == is_buffer_from_outer) {
                        is_buffer_from_outer = true;
                        delete[] buffer_;
                    }

                    buffer_ = next;
                }
            }

            index_ = 0;
            left_ = capacity_;
        }

        if (size > 0) {
            memcpy(buffer_ + index_, pdata + offset, size);
            index_ += size;
            left_ -= size;
        }
        pthread_mutex_unlock(mutex_);

        result = true;
    }

    return result;
}
} /* namespace: commons */
