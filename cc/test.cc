// Generated by Neo

#include <stdio.h>
#include <string.h>

#include <commons/buddy.h>
#include <commons/blocked_queue.h>
#include <commons/commons.h>
#include <commons/handler.h>
#include <commons/pile_buffer.h>
#include <commons/ring_queue.h>

bool is_no_producer = false;
bool is_no_consumer = false;

uint64_t p_spend = 0ULL;
uint64_t p_count = 0ULL;

uint64_t c_spend = 0ULL;
uint64_t c_count = 0ULL;

using namespace commons;

const int kSleepInMs = 1000;
BlockedQueue<int>* buddy_alloc_queue = nullptr;

/***** BlockedQueue Test Unit ************************************************/

const int kMemSize = 320;

void blocked_queue_char_cleaner(void* item) {
    if (nullptr != item) {
        char* info = reinterpret_cast<char*>(item);
        //    LOGV("cleaning: %s\n", info);
        delete info;
    }
}

void* bq_producer(void* handle) {
    if (nullptr == handle) {
        return nullptr;
    }

    BlockedQueue<char>* q = reinterpret_cast<BlockedQueue<char>*>(handle);
    char* base = new char[kMemSize];
    memset(base, 0, kMemSize);

    p_spend = current_ts();
    while (false == is_no_producer) {
        char* info = new char[kMemSize];
        memcpy(info, base, kMemSize);

        //        sprintf(info, "[%zu]: %02X", q->left(), (random_range() &
        //        0xFF));
        //        LOGD("-> %s\n", info);
        q->offer(info);
        ++p_count;
    }
    p_spend = current_ts() - p_spend;
    q->fin();

    delete[] base;

    return handle;
}

void* bq_consumer(void* handle) {
    if (nullptr == handle) {
        return nullptr;
    }

    BlockedQueue<char>* q = reinterpret_cast<BlockedQueue<char>*>(handle);

    while (false == is_no_consumer) {
        char* info = q->poll();
        if (nullptr == info) {
            //            LOGW("fin\n");
            break;
        }

        //        LOGD("<- [%zu] %s\n", q->left(), info);
        delete[] info;
    }

    return handle;
}

int test_blocked_queue() {
    BlockedQueue<char>* queue =
        new BlockedQueue<char>(blocked_queue_char_cleaner);

    is_no_producer = false;
    is_no_consumer = false;

    pthread_t pp;
    pthread_create(&pp, nullptr, bq_producer, queue);

    pthread_t pc;
    pthread_create(&pc, nullptr, bq_consumer, queue);

    msleep(kSleepInMs);

    is_no_producer = true;
    pthread_join(pp, nullptr);

    // test fin by queue
    //    is_no_consumer = true;
    pthread_join(pc, nullptr);

    delete queue;

    // log: 20/ms, non-log: 140~220/ms, non-log-non-copy: 150~450/ms
    LOGD("status: spend = %" PRIu64 ", count = %" PRIu64 ", avg = %.2f\n",
         p_spend, p_count, static_cast<float>(p_count) / p_spend);

    return 0;
}

/***** Buddy Test Unit *******************************************************/

void buddy_cleaner(void* user, int offset) {
    //    LOGD("buddy clean: %d\n", offset);
}

void* b_producer(void* handle) {
    if (nullptr == handle) {
        return nullptr;
    }

    Buddy* b = reinterpret_cast<Buddy*>(handle);

    p_spend = current_ts();
    while (false == is_no_producer) {
        int* locate = new int;

        int size = random_range();

        *locate = kBuddyAllocFailed;
        while (kBuddyAllocFailed == *locate && false == is_no_producer) {
            *locate = b->alloc(size);
        }

        if (*locate >= 0) {
            ++p_count;
            buddy_alloc_queue->offer(locate);
        }

        //        LOGD("alloced %d, locate = %d, size = %zu\n", size, *locate,
        //             buddy_alloc_queue->left());
    }
    p_spend = current_ts() - p_spend;
    buddy_alloc_queue->fin();

    return handle;
}

void* b_consumer(void* handle) {
    if (nullptr == handle) {
        return nullptr;
    }

    Buddy* b = reinterpret_cast<Buddy*>(handle);

    c_spend = current_ts();
    while (false == is_no_consumer) {
        int* locate = buddy_alloc_queue->poll();
        if (nullptr == locate) {
            break;
        }

        //        LOGD("try free locate = %d, left = %zu\n", *locate,
        //             buddy_alloc_queue->left() + 1);
        b->free(*locate);
        ++c_count;
        delete locate;
    }
    c_spend = current_ts() - c_spend;

    return handle;
}

void test_buddy() {
    buddy_alloc_queue = new BlockedQueue<int>(blocked_queue_char_cleaner);

    Buddy* buddy = new Buddy(8, buddy_cleaner, nullptr);

    is_no_producer = false;
    is_no_consumer = false;

    p_count = 0ULL;
    c_count = 0ULL;

    pthread_t pp;
    pthread_create(&pp, nullptr, b_producer, buddy);

    pthread_t pc;
    pthread_create(&pc, nullptr, b_consumer, buddy);

    msleep(kSleepInMs);

    // end consumer first, test auto clean
    is_no_consumer = true;
    pthread_join(pc, nullptr);

    is_no_producer = true;
    pthread_join(pp, nullptr);

    LOGD("status: spend = %" PRIu64 ", count(c/p): %" PRIu64 "/%" PRIu64
         ", avg(c/p): %.2f/%.2f\n",
         p_spend, c_count, p_count, static_cast<float>(c_count) / c_spend,
         static_cast<float>(p_count) / p_spend);

    delete buddy;
    delete buddy_alloc_queue;
}

/***** Handler Test Unit *****************************************************/

class EchoHandler : public Handler {
   public:
    EchoHandler() {}
    ~EchoHandler() {}

    bool handle(int what, int arg1, int arg2, void* obj) {
        switch (arg1) {
            default:
                if (nullptr == obj) {
                    LOGI("echo: %d, %d, %d, nullptr\n", what, arg1, arg2);
                } else {
                    char* info = reinterpret_cast<char*>(obj);
                    LOGI("echo: %d, %d, %d, %s\n", what, arg1, arg2,
                         reinterpret_cast<char*>(obj));
                    delete[] info;
                }
                break;
        }

        return false;
    }
};

void* handler_background(void* handle) {
    if (nullptr == handle) {
        return nullptr;
    }

    Handler* h = reinterpret_cast<Handler*>(handle);

    for (int i = 0; i < 10; ++i) {
        char* info = new char[32];
        sprintf(info, "ts: %" PRIu64 "", current_ts());
        h->send(0, 1, 2, info);
        msleep(kSleepInMs / 10);
    }

    return handle;
}

void test_handler() {
    EchoHandler* handler = new EchoHandler();
    pthread_t ph;
    pthread_create(&ph, nullptr, handler_background, handler);
    pthread_join(ph, nullptr);
    delete handler;
}

/***** PileBuffer Test Unit **************************************************/

const int kPileSize = 64;
const int kBufferSize = 1024;

uint8_t* pile_buffer_target = nullptr;

void* pile_buffer_callback(void* user, const void* data, size_t capacity,
                           const void* additional) {
    //    const uint8_t* pdata = reinterpret_cast<const uint8_t*>(data);
    //    LOGD("pile %3d: %02X\n", pdata[0], pdata[capacity - 1]);
    return pile_buffer_target;
}

void test_pile_buffer() {
    // use inner memory
    //    pile_buffer_target = new uint8_t[kPileSize];
    PileBuffer* pile = new PileBuffer(kPileSize, pile_buffer_callback, nullptr,
                                      pile_buffer_target);

    uint8_t* data = new uint8_t[kBufferSize];

    int left = 0;
    int count = 0;
    int current_length = random_range(0, kBufferSize - 1);

    int sum = 0;

    for (int i = 0; i < 10; ++i) {
        for (int j = 0; j < current_length; ++j) {
            if (0 == ((j + left) % kPileSize)) {
                data[j] = count;
                ++count;
            } else {
                data[j] = random_range();
            }
        }

        left += current_length % kPileSize;
        pile->append(data, current_length, pile_buffer_target);

        sum += current_length;
        current_length = random_range(0, kBufferSize - 1);
    }

    LOGD("progress: %d, avg: %.2f\n", sum, sum / 10.0f);

    delete data;
    delete pile;
    //    delete pile_buffer_target;
}

/***** RingQueue Test Unit ***************************************************/

const int kRingQueueCapacity = 8;

int ring_queue_count = 0;

void ring_queue_callback(void* user, RingQueue* queue, void* data) {
    if (nullptr != queue) {
        // used
        int* pdata = reinterpret_cast<int*>(data);
        //        LOGD("used: %d\n", *pdata);
        delete pdata;

        // renew
        int* data = new int;
        *data = static_cast<int>(c_count++);
        queue->enqueue(data);
    }
}

void* rq_worker(void* handle) {
    if (nullptr == handle) {
        return nullptr;
    }

    RingQueue* q = reinterpret_cast<RingQueue*>(handle);

    c_spend = current_ts();
    while (false == is_no_consumer) {
        const int* data = reinterpret_cast<const int*>(q->head());

        if (nullptr != data) {
            // work with data
            q->dequeue();
        }
    }
    c_spend = current_ts() - c_spend;

    return handle;
}

void test_ring_queue() {
    RingQueue* queue =
        new RingQueue(kRingQueueCapacity, ring_queue_callback, nullptr);

    for (c_count = 0; c_count < kRingQueueCapacity; ++c_count) {
        int* data = new int;
        *data = static_cast<int>(c_count);
        queue->enqueue(data);
    }

    is_no_consumer = false;

    pthread_t pq;
    pthread_create(&pq, nullptr, rq_worker, queue);

    msleep(kSleepInMs);

    is_no_consumer = true;
    pthread_join(pq, nullptr);

    // log: 24, non-log: 100
    LOGD("status: spend = %" PRIu64 ", count = %" PRIu64 ", avg = %.2f\n",
         c_spend, c_count, static_cast<float>(c_count) / c_spend);

    delete queue;
}

/***** main ******************************************************************/

int main(int argc, char* argv[]) {
    init_rand();

    test_handler();
    test_pile_buffer();
    test_buddy();
    test_ring_queue();
    test_blocked_queue();

    return 0;
}
